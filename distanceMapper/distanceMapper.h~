#ifndef DISTANCEMAPPER_H
#define DISTANCEMAPPER_H

#include <qthread.h>
#include <vector>
#include <qmutex.h>


using namespace std;    //please forgive me..

struct componentVector {
  bool attractive;     // is it an attractor or repulsor..
  vector<float> forces;  // the components. 
  componentVector(){};   // empty constructor
  componentVector(vector<float> f, bool a){
    attractive = a;
    forces = f;
  }
};

struct dpoint {
  vector<float> coordinates;    // the current position in n-dimensional space.
  vector<float> forceVectors;   // the forces it is subject to... 
  vector<componentVector> components;   // the component vectors that make up the resulting force vectors.. 
  int index;                    // some kind of identifier..
  float stress;                 // total amount of stress (absolute).. 

  dpoint();  
  dpoint(int i, int dimensions);
  ~dpoint(){}
  
  float adjustVectors(dpoint& p, float d);   // given another point, with an optimal distance of d
                                           // adjust the vectors and return a measure of force in the system.. 
  float move(float forceMultiplier);            // move the point, reset the force vectors to 0 if reset is true.. return the euclidean distance moved
  void resetForces();          // set the stress and force vectors to be 0.. 
  void setPos(vector<float> coords);
};
    

// A class that spawns a thread that attempts to map a set of objects in 2d based
// on all agains all distances.. -- whilst calculating the stress in the system.. 

class DistanceMapper : public QThread
{
  public :
    DistanceMapper(vector<int> expI, vector<vector<float> > d, int dims,  QMutex* mutx, vector<vector<dpoint> >* prntPoints, QObject* prnt);
  ~DistanceMapper();  // don't know how much I'll need for these..
  void restart();     // start the mapping process agains. 
  void updatePosition(int i, float x, float y);  
  void initialisePoints();       // find some nice random positions for the points..

  bool calculating; 
  bool initOK;        // so we can check if it initialised ok.. 
  private :
    vector<int> expts;    // in this case each object represents an experiment, but it could be anything, -- a gene even. !!
  vector<vector<float> > distances;  // the optimal distances. 
  vector<dpoint> points;              // the points representing the objects (usually experiments.. )..  
  vector<vector<dpoint> >* parentPoints;
  QObject* parent;                 // for updating information.. 
  QMutex* pointMutex;

  float moveFactor;               // how much do we move a point by. -- i.e. how much do we multiply the forceVectors by to get a 
                                  // to move distance.. 
  float totalDistance;
  int dimensionality;
  // some functions..
  // don't need because the points will cheat if in the same point.. start all points at the origin.. 

  float adjustVectors();          // adjust the Vectors in the points.. returns the total force
  float movePoints();             // move the points.. and reset force vectors.. -- return distance moved
  void resetPoints();             // just go through and reset the points.. 

  protected :
    void run();                 // the main function, essentially iterates through initialise points and 
};

#endif
