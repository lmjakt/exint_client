#include "distanceViewer.h"
#include "distanceMapper.h"
#include "pointDrawer.h"
#include "tdPointDrawer.h"
//#include "../som/somDrawer.h"
#include "../customWidgets/fSpinBox.h"
#include <qwidget.h>
#include <qlayout.h>
#include <vector>
#include <qmutex.h>
#include <qpushbutton.h>
#include <qlabel.h>
#include <iostream>

using namespace std;

DistanceViewer::DistanceViewer(vector<int> expI, vector<vector<float> > d, QString cName, QWidget* parent, const char* name)
  : QWidget(parent, name)
{
  captionName = cName;  // for offspring windows.. maybe.. mainly.. 
  setCaption(cName);
  distances = d;
  experiments = expI;

  points.reserve(5000);
  
  drawer = new PointDrawer();
  drawer->setCaption(captionName);
  drawer->resize(500, 500);
  drawer->show();
  connect(drawer, SIGNAL(updatePosition(int, float, float)), this, SLOT(updatePosition(int, float, float)) );    // could be direct, but I want to be careful
  connect(drawer, SIGNAL(compareCells(vector<int>, vector<int>)), this, SIGNAL(compareCells(vector<int>, vector<int>)) );
  connect(drawer, SIGNAL(setCoordinates()), this, SLOT(setcoords()) );
  //tdDrawer = new TDPointDrawer(this, "tdDrawer");
  mapper = new DistanceMapper(experiments, distances, 2, &pointMutex, &points, (QObject*)this);    // mapper updates points, then 

  //som = new SomProcess(experiments, distances, &somMutex, &soms);
  //somDrawer = new SomDrawer();     // make it toplevel..
  //somDrawer->setCaption(captionName);
  //cout << "somDrawer made up " << endl;
  //somDrawer->resize(500, 500);
  //cout << "somDrawer resized " << endl;
  //somDrawer->show();
  //cout << "showing somdrawer " << endl;
  // and a timeer..
  
  
  frameTimer = new QTimer(this, "frameTimer");
  connect(frameTimer, SIGNAL(timeout()), this, SLOT(updateFrame()) );

  watchTimer = new QTimer(this, "watchTimer");
  connect(watchTimer, SIGNAL(timeout()), this, SLOT(updatePoints()) );

  //somTimer = new QTimer(this, "somTimer");
  //connect(somTimer, SIGNAL(timeout()), this, SLOT(updateSom()) );

  QLabel* sodLabel = new QLabel("Self Organising Deltoids", this, "sodLabel");
  //QLabel* somLabel = new QLabel("Self Organising Map", this, "somLabel");

  QPushButton* replayButton = new QPushButton("Replay", this, "replayButton");
  connect(replayButton, SIGNAL(clicked()), this, SLOT(replay()) );

  QPushButton* continueButton = new QPushButton("Continue", this, "continueButton");
  connect(continueButton, SIGNAL(clicked()), this, SLOT(continueMapping()) );   // is this legal ?? 

  QPushButton* restartButton = new QPushButton("Restart", this, "restartButton");
  connect(restartButton, SIGNAL(clicked()), this, SLOT(restart()) );   // is this legal ??   

  //QPushButton* somReplay = new QPushButton("Replay Map", this, "somReplay");
  //connect(somReplay, SIGNAL(clicked()), this, SLOT(replayMap()) );

  //QPushButton* somRestart = new QPushButton("Restart SOM", this, "somRestart");
  //connect(somRestart, SIGNAL(clicked()), this, SLOT(restartSom()) );

  //somAlpha = new FSpinBox(0.001, 0.999, 100, this, "somAlpha");
  //somSigma = new FSpinBox(0.1, 10, 100, this, "somSigma");    // not the acutal sigma value, but a sigma multiplier.. 
  //maxDev = new FSpinBox(0, 10, 100, this, "maxDev");
  //maxDev->setFValue(2.5);

  //somAlpha->setFValue(0.5);
  //somSigma->setFValue(2.5);
  
  QPushButton* startButton = new QPushButton("start", this, "startButton");
  connect(startButton, SIGNAL(clicked()), this, SLOT(start()) );

  // set up the layout..
  QVBoxLayout* vbox = new QVBoxLayout(this);
  //  vbox->addWidget(drawer);    // and more later on..
  //vbox->addWidget(tdDrawer);    // and more later on..
  QHBoxLayout* sodButtons = new QHBoxLayout();
  vbox->addWidget(sodLabel);
  vbox->addLayout(sodButtons);
  sodButtons->addWidget(replayButton);
  sodButtons->addWidget(continueButton);
  sodButtons->addWidget(restartButton);
  //vbox->addWidget(somLabel);
  //QHBoxLayout* somButtons = new QHBoxLayout();
  //vbox->addLayout(somButtons);
  //somButtons->addWidget(somReplay);
  //somButtons->addWidget(somRestart);
  //somButtons->addWidget(somAlpha);
  //somButtons->addWidget(somSigma);
  //somButtons->addWidget(maxDev);

  QHBoxLayout* bottomRow = new QHBoxLayout();
  vbox->addLayout(bottomRow);
  bottomRow->addStretch();
  bottomRow->addWidget(startButton);
  //  resize(500, 400);
  
  
  // and start the mapper.. -- it's probably too fast, but there you go.. we could use a timer to do updates,, but hmm
}

DistanceViewer::~DistanceViewer(){
  cout << "destroying distance viewer .. hahhaha" << endl;
  //som->wait();
  mapper->wait();
  //somDrawer->hide();
  //delete somDrawer;
  drawer->hide();
  delete drawer;
  //delete som;
  delete mapper;    // main things to delete.. 
}

void DistanceViewer::start(){
  cout << "start called " << endl;
  followFrame = 0;
  //somFrame = 0; 
  watchTimer->start(20);  // 33 fps.. 
  mapper->start();   // for now, let's just run one of these babies.. !!
  //somDrawer->setMaxDev(maxDev->fvalue());
  //som->setFactors(somAlpha->fvalue(), somSigma->fvalue());
  //som->start();
  //somTimer->start(400);
}

void DistanceViewer::restart(){
  mapper->wait();
  points.resize(0);    // forget the old points, we could store them somehwere, but maybe not.. 
  mapper->initialisePoints();
  followFrame = 0;
  mapper->start();
  watchTimer->start(20);
}

void DistanceViewer::continueMapping(){
  mapper->wait();
  mapper->start();  // is that possible ??
  watchTimer->start(20);
}

// void DistanceViewer::restartSom(){
//   som->wait();          // BAD, as this might take some time, nevertheless, it is probably safter..
//   soms.resize(0);
//   somFrame = 0;
//   somDrawer->setMaxDev(maxDev->fvalue());
//   som->setFactors(somAlpha->fvalue(), somSigma->fvalue());
//   som->initMap();
//   som->start();
//   somTimer->start(400);
// }

void DistanceViewer::customEvent(QCustomEvent* e){
  if(e->type() == 25341){
    updatePoints();
  }else{
    cout << "unknown QCustomEvent type : " << e->type() << endl;
  }
}

void DistanceViewer::updatePoints(){
  // we assume that by this time the points vector has been appended by the thingy..
  // so all we do is read off the last member of it..
  pointMutex.lock();    // hmm   -- stops the other thread if in the middle of this .. 
  if(!mapper->calculating && followFrame >= points.size()){
    cout << "stopping the timer.. " << endl;
    watchTimer->stop();
    pointMutex.unlock();
    return;
  }
  cout << "calling setData followFrame is : " << followFrame << "  and points size is : " << points.size() << endl;
  if(points.size() <= followFrame){
    cerr << "think I should be updating points, but points size is 0,, oh well" << endl;
    pointMutex.unlock();
    return;
  }
  vector<dpoint> localPoints = points[followFrame];
  followFrame++;
  pointMutex.unlock();   // slows down calculation in favour of drawing.. ?? good or bad, I'm not sure.. 
  drawer->setData(localPoints);
  //tdDrawer->setModel(localPoints);
  /// this is terribly inefficient as it involves lots of copying of vectors, but I have a feeling that 
  /// it will be fast enough anyway.. 
}

// void DistanceViewer::updateSom(){
//   somMutex.lock();
//   if(som->finished() && somFrame >= soms.size()){
//     cout << "stopping the some timer " << endl;
//     somTimer->stop();
//     somMutex.unlock();
//     return;
//   }
//   if(somFrame >= soms.size()){
//     cout << "somFrame is larger than or equal to soms.. : " << somFrame << endl;
//     somMutex.unlock();
//     return;
//   }
//   mapDescription ld = soms[somFrame];
//   somFrame++;
//   somMutex.unlock();
//   //  cout << "ld membership size is : " << ld.membership.size() << endl;
//   somDrawer->setData(ld);     // this will involve lots of copying, but never mind.. 
// }

void DistanceViewer::replay(){
  cout << "replay function " << endl;
  frame = 0;
  //somDrawer->setMaxDev(maxDev->fvalue());
  frameTimer->start(10);    // 25 fps.. as not so many frames..
}

// void DistanceViewer::replayMap(){
//   somFrame = 0;
//   somTimer->start(250);   // 4 frames per second..
// }

void DistanceViewer::updateFrame(){
  cout << "calling updateFrame frame is : " << frame << endl;
  if(frame >= points.size()){
    frameTimer->stop();
    return;
  }
  pointMutex.lock();
  vector<dpoint> localPoints = points[frame];
  pointMutex.unlock();
  drawer->setData(localPoints);
  //tdDrawer->setModel(localPoints);
  frame++;
}

void DistanceViewer::updatePosition(int i, float x, float y){
  mapper->updatePosition(i, x, y);
  pointMutex.lock();
  vector<dpoint> localPoints = points.back();
  pointMutex.unlock();
  drawer->setData(localPoints);
  //  mapper->start();
  // watchTimer->start(30);
}

void DistanceViewer::setcoords(){
  cout << "Distnace viewer set coordinates .. " << endl; 
  vector<PointCoordinate> cords;   // just push it back..
  //  vector<dpoint> pts = points.last();     // just the most recent .. -- I forget the function that does this.. 
  vector<dpoint> pts = points[points.size() -1];
  for(uint i=0; i < pts.size(); i++){        
    cords.push_back(PointCoordinate(pts[i].index, pts[i].coordinates));
  }
  emit setCoordinates(cords);   // have these set in the clientWindow, and then have drawing things use a pointer.. to something.. 
}
