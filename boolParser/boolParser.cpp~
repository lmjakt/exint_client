#include boolParser.h

using namespace std;

bool Group::setNext(Unit* p){
  // a group must be followed either by a combiner or by a right bracket, otherwise it's not valid..
  if(p->id() == RB || p->id() == COMB){
    fp = p;
    return(true);
  }
  return(false);
}

bool Group::setPrior(Unit* p){
  // a group must be preceded by a combiner or by a left bracket..
  if(p->id() == LB || p->id() == COMB){
    rp = p;
    return(true);
  }
  return(false);
}

bool Lb::setNext(Unit* p){
  if(p->id() == LB || p->id() == GROUP){     // technically we could have '()' as a valid expression, but I don't have a combiner rule for this.. so let's remove.. 
    fp = p;
    return(true);
  }
  return(false);
}

bool Lb::setPrior(Unit* p){
  if(p->id() == LB || p->id() == GROUP){
    rp = p;
    return(true);
  }
  return(false);
}

bool And::setNext(Unit* p){
  if(p->id() != COMB && p->id() != RB){
    fp = p;
    return(true);
  }
  return(false);
}

bool And::setPrior(Unit* p){
  if(p->id() != COMB && p->id() != LB){
    rp = p;
    return(true);
  }
  return(false);
}

bool And::combine(){
  // do some checking..
  return(true);
}

bool Or::setNext(Unit* p){
  if(p->id() != COMB && p->id() != RB){
    fp = p;
    return(true);
  }
  return(false);
}

bool Or::setPrior(Unit* p){
  if(p->id() != COMB && p->id() != LB){
    rp = p;
    return(true);
  }
  return(false);
}

bool Or::combine(){
  return(true);
}

bool Not::setNext(Unit* p){
  if(p->id() != COMB && p->id() != RB){
    fp = p;
    return(true);
  }
  return(false);
}

bool Not::setPrior(Unit* p){
  if(p->id() != COMB && p->id() != LB){
    rp = p;
    return(true);
  }
  return(false);
}

bool Not::combine(){
  return(true);
}


// so it seems perhaps rather obvious that I could have done with another level of inheritance, but at the moment
// of writing, I'm not actually sure if I'm writint the syntax correctly, so I want to keep new stuff to a minimum.
// I am aware of the obvious unneccessary duplications of code above though.. -- with their increased likelihood of bugs..

BoolParser::BoolParser(QString input, vector<vector<int> > g){
  textOk = true;  // unless set to false by the parseString function..
  text = input;
  
  // and let's make the vectors into sets..
  for(int i=0; i < g.size(); i++){
    set<int> t;  // temporary set..
    for(int j=0; j < g[i].size(); j++){
      t.insert(g[i][j]);
    }
    groups.push_back(t);
  }
  // parse the string and determine if ok.. 
